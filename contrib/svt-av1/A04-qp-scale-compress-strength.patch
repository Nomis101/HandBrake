From deb276382b878d593a9115be960037dea4ffba55 Mon Sep 17 00:00:00 2001
From: Nomis101 <Nomis101@web.de>
Date: Tue, 15 Jul 2025 20:39:58 +0200
Subject: qp-scale-compress-strength

This parameter allows advanced users to switch between four levels of quantizer compression, compressing quantizer values across all hierarchical/temporal layers inside of a mini GOP.


0, which disables the feature.


1 is --qp-scale-compress-strength level 1, conservatively reducing the QP range used by the encoder. Useful for increasing visual consistency at almost all quality levels with next to no cost


2 is --qp-scale-compress-strength level 2, reducing the QP range used by the encoder further. This is useful at higher quality levels where restricting the QP range across layers is more important, or in darker video regions where image features want to be retained more faithfully.


3 is --qp-scale-compress-strength level 3, minimizing the QP range to the maximum. This is useful at maximum fidelity expectations or when the set CRF/QP is very low. In the latter scenario, the feature can actually improve fidelity and coding efficiency simultaneously.


The default value is 0, which preserves SVT-AV1's current behavior.

Signed-off-by: Nomis101 <Nomis101@web.de>
---
 Docs/Parameters.md                |  4 +-
 Source/API/EbDebugMacros.h        |  3 ++
 Source/API/EbSvtAv1Enc.h          | 11 ++++-
 Source/App/app_config.c           |  5 +++
 Source/Lib/Codec/pcs.h            |  1 +
 Source/Lib/Codec/rc_process.c     | 69 +++++++++++++++++++++++++------
 Source/Lib/Globals/enc_handle.c   |  3 ++
 Source/Lib/Globals/enc_settings.c | 10 +++++
 8 files changed, 92 insertions(+), 14 deletions(-)

diff --git a/Docs/Parameters.md b/Docs/Parameters.md
index 3b77e8c4..2cb92493 100644
--- a/Docs/Parameters.md
+++ b/Docs/Parameters.md
@@ -95,7 +95,9 @@ For more information on valid values for specific keys, refer to the [EbEncSetti
 | **EnableVarianceBoost**          | --enable-variance-boost          | [0-1]      | 0           | Enable variance boost                                                                                                                                |
 | **VarianceBoostStrength**        | --variance-boost-strength        | [1-4]      | 2           | Set variance curve strength for variance boost feature [1: mild, 2: gentle [Default], 3: medium, 4: aggressive]                                      |
 | **VarianceOctile**               | --variance-octile                | [1-8]      | 6           | Set variance algorithm 8x8 block selectivity level [1: 1st octile, 4: median, 6: 6th octile [Default], 8: maximum]                                   |
-| **AdaptiveQuantization**         | --aq-mode                        | [0-2]      | 2           | Set adaptive QP level [0: off, 1: variance base using AV1 segments, 2: deltaq pred efficiency]                                                       |
+| **AdaptiveQuantization**         | --aq-mode                        | [0-2]      | 2           | Set adaptive QP level [0: off, 1: variance base using AV1 segments, 2: deltaq pred efficiency]
+|
+| **QpScaleCompressStrength**      | --qp-scale-compress-strength     | [0-3]      | 0           | Sets the strength the QP scale algorithm compresses values across all temporal layers, which results in more consistent video quality (less quality variation across frames in a mini-gop) [0: SVT-AV1 default, 1: SVT-AV1-PSY default, 3: maximum] |
 | **UseFixedQIndexOffsets**        | --use-fixed-qindex-offsets       | [0-2]      | 0           | Overwrite the encoder default hierarchical layer based QP assignment and use fixed Q index offsets                                                   |
 | **KeyFrameQIndexOffset**         | --key-frame-qindex-offset        | [-64-63]   | 0           | Overwrite the encoder default keyframe Q index assignment                                                                                            |
 | **KeyFrameChromaQIndexOffset**   | --key-frame-chroma-qindex-offset | [-64-63]   | 0           | Overwrite the encoder default chroma keyframe Q index assignment                                                                                     |
diff --git a/Source/API/EbDebugMacros.h b/Source/API/EbDebugMacros.h
index 7782744b..3836f8dc 100644
--- a/Source/API/EbDebugMacros.h
+++ b/Source/API/EbDebugMacros.h
@@ -367,6 +367,9 @@ extern "C" {
 #define DEBUG_VAR_BOOST_QP      0
 #define DEBUG_VAR_BOOST_STATS   0
 
+// QP scaling debugging code
+#define DEBUG_QP_SCALING        0
+
 // Quantization matrices
 #define DEBUG_QM_LEVEL          0
 #define DEBUG_STARTUP_MG_SIZE   0
diff --git a/Source/API/EbSvtAv1Enc.h b/Source/API/EbSvtAv1Enc.h
index e98429b1..4225e981 100644
--- a/Source/API/EbSvtAv1Enc.h
+++ b/Source/API/EbSvtAv1Enc.h
@@ -1019,9 +1019,18 @@ typedef struct EbSvtAv1EncConfiguration {
      */
     bool rtc;
 #endif
+
+    /* @brief compresses the QP hierarchical layer scale to improve temporal video consistency
+     * 0: no compression, original SVT-AV1 scaling
+     * 1-3: enable compression, the higher the number the stronger the compression
+     *      (different frame quality fluctuation/mean quality tradeoffs)
+     * Default is 1
+     */
+    uint8_t qp_scale_compress_strength;
+
     // clang-format off
     /*Add 128 Byte Padding to Struct to avoid changing the size of the public configuration struct*/
-    uint8_t padding[128 - (sizeof(uint8_t) * 2)
+    uint8_t padding[128 - (sizeof(uint8_t) * 3)
 #if FTR_RTC_MODE
         - sizeof(bool)
 #endif
diff --git a/Source/App/app_config.c b/Source/App/app_config.c
index c2f3cede..54f5778e 100644
--- a/Source/App/app_config.c
+++ b/Source/App/app_config.c
@@ -203,6 +203,7 @@
 #if FTR_RTC_MODE
 #define RTC_TOKEN "--rtc"
 #endif
+#define QP_SCALE_COMPRESS_STRENGTH_TOKEN "--qp-scale-compress-strength"
 static EbErrorType validate_error(EbErrorType err, const char *token, const char *value) {
     switch (err) {
     case EB_ErrorNone: return EB_ErrorNone;
@@ -947,6 +948,8 @@ ConfigDescription config_entry_variance_boost[] = {
     {VARIANCE_BOOST_STRENGTH_TOKEN, "Variance boost strength, default is 2 [1-4]"},
     {VARIANCE_OCTILE_TOKEN, "Octile for variance boost, default is 6 [1-8]"},
     {VARIANCE_BOOST_CURVE_TOKEN, "Curve for variance boost, default is 0 [0-3]"},
+    // QP scale compress
+    {QP_SCALE_COMPRESS_STRENGTH_TOKEN, "QP scale compress strength, default is 1 [0-3]"},
     // Termination
     {NULL, NULL}};
 
@@ -1146,6 +1149,8 @@ ConfigEntry config_entry[] = {
     // Real-time Coding
     {RTC_TOKEN, "RealTime", set_cfg_generic_token},
 #endif
+    // QP scale compression
+    {QP_SCALE_COMPRESS_STRENGTH_TOKEN, "QpScaleCompressStrength", set_cfg_generic_token},
     // Termination
     {NULL, NULL, NULL}};
 
diff --git a/Source/Lib/Codec/pcs.h b/Source/Lib/Codec/pcs.h
index 03c8b3f3..17514395 100644
--- a/Source/Lib/Codec/pcs.h
+++ b/Source/Lib/Codec/pcs.h
@@ -1372,6 +1372,7 @@ typedef struct PictureControlSetInitData {
     uint8_t variance_boost_strength;
     uint8_t variance_octile;
     uint8_t tf_strength;
+    uint8_t qp_scale_compress_strength;
 #if OPT_ALLINTRA_STILLIMAGE_2
     bool allintra;
 #endif
diff --git a/Source/Lib/Codec/rc_process.c b/Source/Lib/Codec/rc_process.c
index 4378096d..3f235c33 100644
--- a/Source/Lib/Codec/rc_process.c
+++ b/Source/Lib/Codec/rc_process.c
@@ -815,6 +815,7 @@ static int svt_av1_get_q_index_from_qstep_ratio(int leaf_qindex, double qstep_ra
     return qindex;
 }
 static const double r0_weight[3] = {0.75 /* I_SLICE */, 0.9 /* BASE */, 1 /* NON-BASE */};
+static const double qp_scale_compress_weight[4] = {1, 1.125, 1.25, 1.375};
 /******************************************************
  * crf_qindex_calc
  * Assign the q_index per frame.
@@ -847,13 +848,26 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
 #endif
     // Since many frames can be processed at the same time, storing/using arf_q in rc param is not sufficient and will create a run to run.
     // So, for each frame, arf_q is updated based on the qp of its references.
-    rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[0][0] << 2) + 2));
-#if CLN_REMOVE_P_SLICE
-    if (pcs->slice_type == B_SLICE && pcs->ppcs->ref_list1_count_try)
-#else
-    if (pcs->slice_type == B_SLICE)
+    if (scs-> static_config.qp_scale_compress_strength == 0) {
+        rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[0][0] << 2) + 2));
+        #if CLN_REMOVE_P_SLICE
+            if (pcs->slice_type == B_SLICE && pcs->ppcs->ref_list1_count_try)
+        #else
+            if (pcs->slice_type == B_SLICE)
+        #endif
+            rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[1][0] << 2) + 2));
+    } else {
+        // new code that accurately converts back arf qindex values
+        // prevents the case of unintentional qindex drifting due to repeatedly adding 2 to each calculated temporal layer's qindex
+        rc->arf_q = MAX(rc->arf_q, quantizer_to_qindex[pcs->ref_pic_qp_array[0][0]]);
+        if (pcs->slice_type == B_SLICE)
+            rc->arf_q = MAX(rc->arf_q, quantizer_to_qindex[pcs->ref_pic_qp_array[1][0]]);
+    }
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("Frame %llu, temp. level %i, active worst quality %i, qstep based calc %i\n",
+           pcs->picture_number, pcs->temporal_layer_index, active_worst_quality, use_qstep_based_q_calc);
+    SVT_DEBUG("  ref1 q %i, ref2 q %i, arf q %i\n", (pcs->ref_pic_qp_array[0][0] << 2) + 2, (pcs->slice_type == B_SLICE) ? (pcs->ref_pic_qp_array[1][0] << 2) + 2 : 0, rc->arf_q);
 #endif
-        rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[1][0] << 2) + 2));
 
     // r0 scaling
     // TPL may only look at a subset of available pictures in tpl group, which may affect the r0 calcuation.
@@ -870,6 +884,10 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
         int max_boost = ppcs->used_tpl_frame_num * KB;
         rc->kf_boost  = AOMMIN(rc->kf_boost, max_boost);
 
+#if DEBUG_QP_SCALING
+        SVT_DEBUG("  r0 %f, adj. factor %f, hier levels, %i, islice div factor %f, kf boost %i\n",
+               ppcs->r0, ppcs->tpl_ctrls.r0_adjust_factor, hierarchical_levels, tpl_hl_islice_div_factor[hierarchical_levels], rc->kf_boost);
+#endif
     } else {
         if (use_qstep_based_q_calc) {
             if (ppcs->tpl_ctrls.r0_adjust_factor) {
@@ -885,6 +903,10 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
         }
         rc->gfu_boost = get_gfu_boost_from_r0_lap(
             min_boost_factor, MAX_GFUBOOST_FACTOR, ppcs->r0, num_stats_required_for_gfu_boost);
+#if DEBUG_QP_SCALING
+        SVT_DEBUG("  r0 %f, adj. factor %f, hier levels %i, frame div factor %f, gfu boost %i\n",
+               ppcs->r0, ppcs->tpl_ctrls.r0_adjust_factor, hierarchical_levels, tpl_hl_base_frame_div_factor[hierarchical_levels], rc->gfu_boost);
+#endif
     }
 
     q = active_worst_quality;
@@ -897,9 +919,15 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
             (ppcs->tpl_group_size < (uint32_t)(2 << pcs->ppcs->hierarchical_levels)))
             weight = MIN(weight + 0.1, 1);
 
-        const double qstep_ratio             = sqrt(ppcs->r0) * weight;
+        double qstep_ratio = sqrt(ppcs->r0) * weight * qp_scale_compress_weight[scs->static_config.qp_scale_compress_strength];
+        if (pcs->scs->static_config.qp_scale_compress_strength) {
+            // clamp qstep_ratio so it doesn't get past the weight value
+            qstep_ratio = MIN(weight, qstep_ratio);
+        }
         const int    qindex_from_qstep_ratio = svt_av1_get_q_index_from_qstep_ratio(qindex, qstep_ratio, bit_depth);
-
+#if DEBUG_QP_SCALING
+        SVT_DEBUG("  qstep based calc: r0 weight %f, qstep ratio %f, qindex from qstep ratio %i\n", weight, qstep_ratio, qindex_from_qstep_ratio);
+#endif
         if (!frame_is_intra_only(ppcs))
             rc->arf_q = qindex_from_qstep_ratio;
         active_best_quality  = clamp(qindex_from_qstep_ratio, rc->best_quality, qindex);
@@ -929,7 +957,9 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
             if (rf_level == GF_ARF_LOW) {
                 int w1 = non_base_qindex_weight_ref[hierarchical_levels];
                 int w2 = non_base_qindex_weight_wq[hierarchical_levels];
-
+#if DEBUG_QP_SCALING
+                SVT_DEBUG("  w1 %i, w2 %i, w1 ref intra pct %i\n", w1, w2, w1 + pcs->ref_intra_percentage);
+#endif
                 if (temporal_layer > 0 && pcs->ppcs->hierarchical_levels == 5) {
                     w1 += pcs->ref_intra_percentage;
                 }
@@ -937,12 +967,23 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
                 while (tmp_layer_delta--)
                     active_best_quality = (w1 * active_best_quality + (w2 * cq_level) + ((w1 + w2) / 2)) / (w1 + w2);
             }
+#if DEBUG_QP_SCALING
+            SVT_DEBUG("  ref based calc: ref tmp layer %i, delta %i\n", ref_tmp_layer, tmp_layer_delta);
+#endif
         }
     }
-
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("  before tmp layer adj: abq %i, awq %i, arf_q %i\n", active_best_quality, active_worst_quality, rc->arf_q);
+#endif
     if (temporal_layer)
         active_best_quality = MAX(active_best_quality, rc->arf_q);
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("  after tmp layer adj: abq %i, awq %i\n", active_best_quality, active_worst_quality);
+#endif
     adjust_active_best_and_worst_quality(pcs, rc, rf_level, &active_worst_quality, &active_best_quality);
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("  after adj: abq %i, awq %i\n", active_best_quality, active_worst_quality);
+#endif
     q = active_best_quality;
     clamp(q, active_best_quality, active_worst_quality);
     ppcs->top_index    = active_worst_quality;
@@ -993,7 +1034,7 @@ static int cqp_qindex_calc(PictureControlSet *pcs, int qindex) {
     int active_worst_quality = qindex;
     if (pcs->temporal_layer_index == 0) {
         const double qratio_grad = pcs->ppcs->hierarchical_levels <= 4 ? 0.3 : 0.2;
-        const double qstep_ratio = 0.2 + (1.0 - (double)active_worst_quality / MAXQ) * qratio_grad;
+        const double qstep_ratio = (0.2 + (1.0 - (double)active_worst_quality / MAXQ) * qratio_grad) * qp_scale_compress_weight[pcs->scs->static_config.qp_scale_compress_strength];
         q = scs->cqp_base_q = svt_av1_get_q_index_from_qstep_ratio(active_worst_quality, qstep_ratio, bit_depth);
     } else if (pcs->ppcs->is_ref && pcs->temporal_layer_index < pcs->ppcs->hierarchical_levels) {
         int this_height = pcs->ppcs->temporal_layer_index + 1;
@@ -2709,7 +2750,11 @@ static int rc_pick_q_and_bounds(PictureControlSet *pcs) {
         const unsigned int r0_weight_idx = !frame_is_intra_only(pcs->ppcs) + !!pcs->ppcs->temporal_layer_index;
         assert(r0_weight_idx <= 2);
         double       weight                  = r0_weight[r0_weight_idx];
-        const double qstep_ratio             = sqrt(pcs->ppcs->r0) * weight;
+        double qstep_ratio             = sqrt(pcs->ppcs->r0) * weight * qp_scale_compress_weight[pcs->scs->static_config.qp_scale_compress_strength];
+        if (pcs->scs->static_config.qp_scale_compress_strength) {
+            // clamp qstep_ratio so it doesn't get past the weight value
+            qstep_ratio = MIN(weight, qstep_ratio);
+        }
         int          qindex_from_qstep_ratio = svt_av1_get_q_index_from_qstep_ratio(
             rc->active_worst_quality, qstep_ratio, scs->static_config.encoder_bit_depth);
         if (pcs->ppcs->sc_class1 && scs->passes == 1 && enc_ctx->rc_cfg.mode == AOM_VBR &&
diff --git a/Source/Lib/Globals/enc_handle.c b/Source/Lib/Globals/enc_handle.c
index 4c352eda..f607ebc8 100644
--- a/Source/Lib/Globals/enc_handle.c
+++ b/Source/Lib/Globals/enc_handle.c
@@ -1738,6 +1738,7 @@ EB_API EbErrorType svt_av1_enc_init(EbComponentType *svt_enc_component)
         input_data.variance_boost_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.variance_boost_strength;
         input_data.variance_octile = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.variance_octile;
         input_data.tf_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.tf_strength;
+        input_data.qp_scale_compress_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.qp_scale_compress_strength;
         input_data.static_config = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config;
 #if OPT_ALLINTRA_STILLIMAGE_2
         input_data.allintra = enc_handle_ptr->scs_instance_array[instance_index]->scs->allintra;
@@ -5752,6 +5753,8 @@ static void copy_api_from_app(
         scs->static_config.variance_boost_curve = 3;
     }
 
+    // QP scaling compression
+    scs->static_config.qp_scale_compress_strength = config_struct->qp_scale_compress_strength;
     return;
 }
 
diff --git a/Source/Lib/Globals/enc_settings.c b/Source/Lib/Globals/enc_settings.c
index 26f23578..b309ecac 100644
--- a/Source/Lib/Globals/enc_settings.c
+++ b/Source/Lib/Globals/enc_settings.c
@@ -937,6 +937,11 @@ EbErrorType svt_av1_verify_settings(SequenceControlSet *scs) {
         return_error = EB_ErrorBadParameter;
     }
 
+    if (config->qp_scale_compress_strength > 3) {
+        SVT_ERROR("Instance %u: QP scale compress strength must be between 0 and 3\n", channel_number + 1);
+        return_error = EB_ErrorBadParameter;
+    }
+
     return return_error;
 }
 
@@ -1103,6 +1108,7 @@ EbErrorType svt_av1_set_default_params(EbSvtAv1EncConfiguration *config_ptr) {
     config_ptr->sharpness                         = 0;
     config_ptr->lossless                          = false;
     config_ptr->avif                              = false;
+    config_ptr->qp_scale_compress_strength        = 1;
     return return_error;
 }
 
@@ -1246,6 +1252,9 @@ void svt_av1_print_lib_params(SequenceControlSet *scs) {
         case 2: SVT_INFO("SVT [config]: temporal filtering strength \t\t\t\t\t: auto\n"); break;
         default: break;
         }
+
+        SVT_INFO("SVT [config]: QP scale compress strength \t\t\t: %d\n",
+                 config->qp_scale_compress_strength);
     }
 #if CLN_SEG_COUNTS
 #if DEBUG_BUFFERS
@@ -2130,6 +2139,7 @@ EB_API EbErrorType svt_av1_enc_parse_parameter(EbSvtAv1EncConfiguration *config_
         {"variance-boost-strength", &config_struct->variance_boost_strength},
         {"variance-octile", &config_struct->variance_octile},
         {"variance-boost-curve", &config_struct->variance_boost_curve},
+        {"qp-scale-compress-strength", &config_struct->qp_scale_compress_strength},
         {"fast-decode", &config_struct->fast_decode},
         {"luminance-qp-bias", &config_struct->luminance_qp_bias},
         {"enable-tf", &config_struct->enable_tf},
-- 
2.50.1

