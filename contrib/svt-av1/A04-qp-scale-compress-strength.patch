From 6abe3942d0a9fe2dceff72c8da3fd5825fc11665 Mon Sep 17 00:00:00 2001
From: Nomis101 <Nomis101@web.de>
Date: Sun, 3 Aug 2025 07:38:38 +0200
Subject: qp-scale-compress-strength

This parameter allows advanced users to switch between four levels of quantizer compression, compressing quantizer values across all hierarchical/temporal layers inside of a mini GOP.


0, which disables the feature.


1 is --qp-scale-compress-strength level 1, conservatively reducing the QP range used by the encoder. Useful for increasing visual consistency at almost all quality levels with next to no cost


2 is --qp-scale-com
---
 Docs/Parameters.md                |  5 ++-
 Source/API/EbDebugMacros.h        |  3 ++
 Source/API/EbSvtAv1Enc.h          | 12 +++++-
 Source/App/app_config.c           |  7 +++-
 Source/Lib/Codec/pcs.h            |  1 +
 Source/Lib/Codec/rc_process.c     | 62 +++++++++++++++++++++++++++----
 Source/Lib/Globals/enc_handle.c   |  5 ++-
 Source/Lib/Globals/enc_settings.c | 10 +++++
 8 files changed, 92 insertions(+), 13 deletions(-)

diff --git a/Docs/Parameters.md b/Docs/Parameters.md
index 63b16475..64f8c471 100644
--- a/Docs/Parameters.md
+++ b/Docs/Parameters.md
@@ -95,7 +95,10 @@ For more information on valid values for specific keys, refer to the [EbEncSetti
 | **EnableVarianceBoost**          | --enable-variance-boost          | [0-1]      | 0           | Enable variance boost                                                                                                                                |
 | **VarianceBoostStrength**        | --variance-boost-strength        | [1-4]      | 2           | Set variance curve strength for variance boost feature [1: mild, 2: gentle [Default], 3: medium, 4: aggressive]                                      |
 | **VarianceOctile**               | --variance-octile                | [1-8]      | 6           | Set variance algorithm 8x8 block selectivity level [1: 1st octile, 4: median, 6: 6th octile [Default], 8: maximum]                                   |
-| **AdaptiveQuantization**         | --aq-mode                        | [0-2]      | 2           | Set adaptive QP level [0: off, 1: variance base using AV1 segments, 2: deltaq pred efficiency]                                                       |
+| **AdaptiveQuantization**         | --aq-mode                        | [0-2]      | 2           | Set adaptive QP level [0: off, 1: variance base using AV1 segments, 2: deltaq pred efficiency]                                                       
+|
+| **QpScaleCompressStrength**      | --qp-scale-compress-strength     | [0-3]      | 0           | Sets the strength the QP scale algorithm compresses values across all temporal layers, which results in more consistent video quality (less quality variation across frames in a mini-gop) |
+|
 | **UseFixedQIndexOffsets**        | --use-fixed-qindex-offsets       | [0-2]      | 0           | Overwrite the encoder default hierarchical layer based QP assignment and use fixed Q index offsets                                                   |
 | **KeyFrameQIndexOffset**         | --key-frame-qindex-offset        | [-64-63]   | 0           | Overwrite the encoder default keyframe Q index assignment                                                                                            |
 | **KeyFrameChromaQIndexOffset**   | --key-frame-chroma-qindex-offset | [-64-63]   | 0           | Overwrite the encoder default chroma keyframe Q index assignment                                                                                     |
diff --git a/Source/API/EbDebugMacros.h b/Source/API/EbDebugMacros.h
index 9d2a2649..4a5890da 100644
--- a/Source/API/EbDebugMacros.h
+++ b/Source/API/EbDebugMacros.h
@@ -78,6 +78,9 @@ extern "C" {
 #define DEBUG_VAR_BOOST_QP      0
 #define DEBUG_VAR_BOOST_STATS   0
 
+// QP scaling debugging code
+#define DEBUG_QP_SCALING        0
+
 // Quantization matrices
 #define DEBUG_QM_LEVEL          0
 #define DEBUG_STARTUP_MG_SIZE   0
diff --git a/Source/API/EbSvtAv1Enc.h b/Source/API/EbSvtAv1Enc.h
index b4ba6a65..cf63d72b 100644
--- a/Source/API/EbSvtAv1Enc.h
+++ b/Source/API/EbSvtAv1Enc.h
@@ -1,4 +1,4 @@
-﻿/*
+/*
 * Copyright(c) 2019 Intel Corporation
 *
 * This source code is subject to the terms of the BSD 3-Clause Clear License and
@@ -963,6 +963,14 @@ typedef struct EbSvtAv1EncConfiguration {
      * Default is 15.
      */
     uint8_t max_chroma_qm_level;
+    
+    /* @brief compresses the QP hierarchical layer scale to improve temporal video consistency
+     * 0: no compression, original SVT-AV1 scaling
+     * 1-3: enable compression, the higher the number the stronger the compression
+     *      (different frame quality fluctuation/mean quality tradeoffs)
+     * Default is 1
+     */
+    uint8_t qp_scale_compress_strength;
 
     /* @brief Signal to the library to enable real-time coding
      *
@@ -977,7 +985,7 @@ typedef struct EbSvtAv1EncConfiguration {
 
     // clang-format off
     /*Add 128 Byte Padding to Struct to avoid changing the size of the public configuration struct*/
-    uint8_t padding[128 - (sizeof(uint8_t) * 2)
+    uint8_t padding[128 - (sizeof(uint8_t) * 3)
         - sizeof(bool)
 #if FTR_SFRAME_POSI
         - sizeof(SvtAv1SFramePositions)
diff --git a/Source/App/app_config.c b/Source/App/app_config.c
index b9150484..c5c3c487 100644
--- a/Source/App/app_config.c
+++ b/Source/App/app_config.c
@@ -1,4 +1,4 @@
-﻿/*
+/*
 * Copyright(c) 2019 Intel Corporation
 *
 * This source code is subject to the terms of the BSD 3-Clause Clear License and
@@ -204,6 +204,7 @@
 #define LOSSLESS_TOKEN "--lossless"
 #define AVIF_TOKEN "--avif"
 #define RTC_TOKEN "--rtc"
+#define QP_SCALE_COMPRESS_STRENGTH_TOKEN "--qp-scale-compress-strength"
 static EbErrorType validate_error(EbErrorType err, const char *token, const char *value) {
     switch (err) {
     case EB_ErrorNone: return EB_ErrorNone;
@@ -957,6 +958,8 @@ ConfigDescription config_entry_variance_boost[] = {
     {VARIANCE_BOOST_STRENGTH_TOKEN, "Variance boost strength, default is 2 [1-4]"},
     {VARIANCE_OCTILE_TOKEN, "Octile for variance boost, default is 6 [1-8]"},
     {VARIANCE_BOOST_CURVE_TOKEN, "Curve for variance boost, default is 0 [0-3]"},
+    // QP scale compress
+    {QP_SCALE_COMPRESS_STRENGTH_TOKEN, "QP scale compress strength, default is 1 [0-3]"},
     // Termination
     {NULL, NULL}};
 
@@ -1158,6 +1161,8 @@ ConfigEntry config_entry[] = {
     {AVIF_TOKEN, "Avif", set_cfg_generic_token},
     // Real-time Coding
     {RTC_TOKEN, "RealTime", set_cfg_generic_token},
+    // QP scale compression
+    {QP_SCALE_COMPRESS_STRENGTH_TOKEN, "QpScaleCompressStrength", set_cfg_generic_token},
     // Termination
     {NULL, NULL, NULL}};
 
diff --git a/Source/Lib/Codec/pcs.h b/Source/Lib/Codec/pcs.h
index aef56097..e305f994 100644
--- a/Source/Lib/Codec/pcs.h
+++ b/Source/Lib/Codec/pcs.h
@@ -1190,6 +1190,7 @@ typedef struct PictureControlSetInitData {
     uint8_t variance_boost_strength;
     uint8_t variance_octile;
     uint8_t tf_strength;
+    uint8_t qp_scale_compress_strength;
     bool    allintra;
 } PictureControlSetInitData;
 
diff --git a/Source/Lib/Codec/rc_process.c b/Source/Lib/Codec/rc_process.c
index 6d64e027..85eb5c85 100644
--- a/Source/Lib/Codec/rc_process.c
+++ b/Source/Lib/Codec/rc_process.c
@@ -791,6 +791,7 @@ static int svt_av1_get_q_index_from_qstep_ratio(int leaf_qindex, double qstep_ra
     return qindex;
 }
 static const double r0_weight[3] = {0.75 /* I_SLICE */, 0.9 /* BASE */, 1 /* NON-BASE */};
+static const double qp_scale_compress_weight[4] = {1, 1.125, 1.25, 1.375};
 /******************************************************
  * crf_qindex_calc
  * Assign the q_index per frame.
@@ -819,9 +820,22 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
     bool use_qstep_based_q_calc = ppcs->r0_qps;
     // Since many frames can be processed at the same time, storing/using arf_q in rc param is not sufficient and will create a run to run.
     // So, for each frame, arf_q is updated based on the qp of its references.
-    rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[0][0] << 2) + 2));
-    if (pcs->slice_type == B_SLICE && pcs->ppcs->ref_list1_count_try)
-        rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[1][0] << 2) + 2));
+    if (scs-> static_config.qp_scale_compress_strength == 0) {
+        rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[0][0] << 2) + 2));
+        if (pcs->slice_type == B_SLICE && pcs->ppcs->ref_list1_count_try)
+            rc->arf_q = MAX(rc->arf_q, ((pcs->ref_pic_qp_array[1][0] << 2) + 2));
+    } else {
+        // new code that accurately converts back arf qindex values
+        // prevents the case of unintentional qindex drifting due to repeatedly adding 2 to each calculated temporal layer's qindex
+        rc->arf_q = MAX(rc->arf_q, quantizer_to_qindex[pcs->ref_pic_qp_array[0][0]]);
+        if (pcs->slice_type == B_SLICE)
+            rc->arf_q = MAX(rc->arf_q, quantizer_to_qindex[pcs->ref_pic_qp_array[1][0]]);
+    }
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("Frame %llu, temp. level %i, active worst quality %i, qstep based calc %i\n",
+           pcs->picture_number, pcs->temporal_layer_index, active_worst_quality, use_qstep_based_q_calc);
+    SVT_DEBUG("  ref1 q %i, ref2 q %i, arf q %i\n", (pcs->ref_pic_qp_array[0][0] << 2) + 2, (pcs->slice_type == B_SLICE) ? (pcs->ref_pic_qp_array[1][0] << 2) + 2 : 0, rc->arf_q);
+#endif
 
     // r0 scaling
     // TPL may only look at a subset of available pictures in tpl group, which may affect the r0 calcuation.
@@ -838,6 +852,10 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
         int max_boost = ppcs->used_tpl_frame_num * KB;
         rc->kf_boost  = AOMMIN(rc->kf_boost, max_boost);
 
+#if DEBUG_QP_SCALING
+        SVT_DEBUG("  r0 %f, adj. factor %f, hier levels, %i, islice div factor %f, kf boost %i\n",
+               ppcs->r0, ppcs->tpl_ctrls.r0_adjust_factor, hierarchical_levels, tpl_hl_islice_div_factor[hierarchical_levels], rc->kf_boost);
+#endif
     } else {
         if (use_qstep_based_q_calc) {
             if (ppcs->tpl_ctrls.r0_adjust_factor) {
@@ -853,6 +871,10 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
         }
         rc->gfu_boost = get_gfu_boost_from_r0_lap(
             min_boost_factor, MAX_GFUBOOST_FACTOR, ppcs->r0, num_stats_required_for_gfu_boost);
+#if DEBUG_QP_SCALING
+        SVT_DEBUG("  r0 %f, adj. factor %f, hier levels %i, frame div factor %f, gfu boost %i\n",
+               ppcs->r0, ppcs->tpl_ctrls.r0_adjust_factor, hierarchical_levels, tpl_hl_base_frame_div_factor[hierarchical_levels], rc->gfu_boost);
+#endif
     }
 
     q = active_worst_quality;
@@ -865,9 +887,15 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
             (ppcs->tpl_group_size < (uint32_t)(2 << pcs->ppcs->hierarchical_levels)))
             weight = MIN(weight + 0.1, 1);
 
-        const double qstep_ratio             = sqrt(ppcs->r0) * weight;
+        double qstep_ratio = sqrt(ppcs->r0) * weight * qp_scale_compress_weight[scs->static_config.qp_scale_compress_strength];
+        if (pcs->scs->static_config.qp_scale_compress_strength) {
+            // clamp qstep_ratio so it doesn't get past the weight value
+            qstep_ratio = MIN(weight, qstep_ratio);
+        }
         const int    qindex_from_qstep_ratio = svt_av1_get_q_index_from_qstep_ratio(qindex, qstep_ratio, bit_depth);
-
+#if DEBUG_QP_SCALING
+        SVT_DEBUG("  qstep based calc: r0 weight %f, qstep ratio %f, qindex from qstep ratio %i\n", weight, qstep_ratio, qindex_from_qstep_ratio);
+#endif
         if (!frame_is_intra_only(ppcs))
             rc->arf_q = qindex_from_qstep_ratio;
         active_best_quality  = clamp(qindex_from_qstep_ratio, rc->best_quality, qindex);
@@ -890,6 +918,9 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
                 int w1 = non_base_qindex_weight_ref[hierarchical_levels];
                 int w2 = non_base_qindex_weight_wq[hierarchical_levels];
 
+#if DEBUG_QP_SCALING
+                SVT_DEBUG("  w1 %i, w2 %i, w1 ref intra pct %i\n", w1, w2, w1 + pcs->ref_intra_percentage);
+#endif
                 if (temporal_layer > 0 && pcs->ppcs->hierarchical_levels == 5) {
                     w1 += pcs->ref_intra_percentage;
                 }
@@ -897,12 +928,23 @@ static int crf_qindex_calc(PictureControlSet *pcs, RATE_CONTROL *rc, int qindex)
                 while (tmp_layer_delta--)
                     active_best_quality = (w1 * active_best_quality + (w2 * cq_level) + ((w1 + w2) / 2)) / (w1 + w2);
             }
+#if DEBUG_QP_SCALING
+            SVT_DEBUG("  ref based calc: ref tmp layer %i, delta %i\n", ref_tmp_layer, tmp_layer_delta);
+#endif
         }
     }
-
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("  before tmp layer adj: abq %i, awq %i, arf_q %i\n", active_best_quality, active_worst_quality, rc->arf_q);
+#endif
     if (temporal_layer)
         active_best_quality = MAX(active_best_quality, rc->arf_q);
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("  after tmp layer adj: abq %i, awq %i\n", active_best_quality, active_worst_quality);
+#endif
     adjust_active_best_and_worst_quality(pcs, rc, rf_level, &active_worst_quality, &active_best_quality);
+#if DEBUG_QP_SCALING
+    SVT_DEBUG("  after adj: abq %i, awq %i\n", active_best_quality, active_worst_quality);
+#endif
     q = active_best_quality;
     clamp(q, active_best_quality, active_worst_quality);
     ppcs->top_index    = active_worst_quality;
@@ -949,7 +991,7 @@ static int cqp_qindex_calc(PictureControlSet *pcs, int qindex) {
     int active_worst_quality = qindex;
     if (pcs->temporal_layer_index == 0) {
         const double qratio_grad = pcs->ppcs->hierarchical_levels <= 4 ? 0.3 : 0.2;
-        const double qstep_ratio = 0.2 + (1.0 - (double)active_worst_quality / MAXQ) * qratio_grad;
+        const double qstep_ratio = (0.2 + (1.0 - (double)active_worst_quality / MAXQ) * qratio_grad) * qp_scale_compress_weight[pcs->scs->static_config.qp_scale_compress_strength];
         q = scs->cqp_base_q = svt_av1_get_q_index_from_qstep_ratio(active_worst_quality, qstep_ratio, bit_depth);
     } else if (pcs->ppcs->is_ref && pcs->temporal_layer_index < pcs->ppcs->hierarchical_levels) {
         int this_height = pcs->ppcs->temporal_layer_index + 1;
@@ -2465,7 +2507,11 @@ static int rc_pick_q_and_bounds(PictureControlSet *pcs) {
         const unsigned int r0_weight_idx = !frame_is_intra_only(pcs->ppcs) + !!pcs->ppcs->temporal_layer_index;
         assert(r0_weight_idx <= 2);
         double       weight                  = r0_weight[r0_weight_idx];
-        const double qstep_ratio             = sqrt(pcs->ppcs->r0) * weight;
+        double qstep_ratio             = sqrt(pcs->ppcs->r0) * weight * qp_scale_compress_weight[pcs->scs->static_config.qp_scale_compress_strength];
+        if (pcs->scs->static_config.qp_scale_compress_strength) {
+            // clamp qstep_ratio so it doesn't get past the weight value
+            qstep_ratio = MIN(weight, qstep_ratio);
+        }
         int          qindex_from_qstep_ratio = svt_av1_get_q_index_from_qstep_ratio(
             rc->active_worst_quality, qstep_ratio, scs->static_config.encoder_bit_depth);
         if (pcs->ppcs->sc_class1 && scs->passes == 1 && enc_ctx->rc_cfg.mode == AOM_VBR &&
diff --git a/Source/Lib/Globals/enc_handle.c b/Source/Lib/Globals/enc_handle.c
index 6c2026e8..a0178fa9 100644
--- a/Source/Lib/Globals/enc_handle.c
+++ b/Source/Lib/Globals/enc_handle.c
@@ -1525,6 +1525,7 @@ EB_API EbErrorType svt_av1_enc_init(EbComponentType *svt_enc_component)
         input_data.variance_boost_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.variance_boost_strength;
         input_data.variance_octile = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.variance_octile;
         input_data.tf_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.tf_strength;
+        input_data.qp_scale_compress_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.qp_scale_compress_strength;
         input_data.static_config = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config;
         input_data.allintra = enc_handle_ptr->scs_instance_array[instance_index]->scs->allintra;
         EB_NEW(
@@ -4642,7 +4643,9 @@ static void copy_api_from_app(
         SVT_INFO("HDR content with PQ transfer detected, switching to PQ-optimized curve\n");
         scs->static_config.variance_boost_curve = 3;
     }
-
+    
+    // QP scaling compression
+    scs->static_config.qp_scale_compress_strength = config_struct->qp_scale_compress_strength;
     return;
 }
 
diff --git a/Source/Lib/Globals/enc_settings.c b/Source/Lib/Globals/enc_settings.c
index aab3025e..2c5d303f 100644
--- a/Source/Lib/Globals/enc_settings.c
+++ b/Source/Lib/Globals/enc_settings.c
@@ -895,6 +895,11 @@ EbErrorType svt_av1_verify_settings(SequenceControlSet *scs) {
         return_error = EB_ErrorBadParameter;
     }
 
+    if (config->qp_scale_compress_strength > 3) {
+        SVT_ERROR("Instance %u: QP scale compress strength must be between 0 and 3\n", channel_number + 1);
+        return_error = EB_ErrorBadParameter;
+    }
+
     return return_error;
 }
 
@@ -1047,6 +1052,7 @@ EbErrorType svt_av1_set_default_params(EbSvtAv1EncConfiguration *config_ptr) {
     config_ptr->sharpness                         = 0;
     config_ptr->lossless                          = false;
     config_ptr->avif                              = false;
+    config_ptr->qp_scale_compress_strength        = 1;
 #if FTR_SFRAME_POSI
     config_ptr->sframe_posi.sframe_num   = 0;
     config_ptr->sframe_posi.sframe_posis = NULL;
@@ -1180,6 +1186,9 @@ void svt_av1_print_lib_params(SequenceControlSet *scs) {
         case 2: SVT_INFO("SVT [config]: temporal filtering strength \t\t\t\t\t: auto\n"); break;
         default: break;
         }
+
+        SVT_INFO("SVT [config]: QP scale compress strength \t\t\t: %d\n",
+                 config->qp_scale_compress_strength);
     }
 #if DEBUG_BUFFERS
     SVT_INFO("SVT [config]: INPUT / OUTPUT \t\t\t\t\t\t\t: %d / %d\n",
@@ -2041,6 +2050,7 @@ EB_API EbErrorType svt_av1_enc_parse_parameter(EbSvtAv1EncConfiguration *config_
         {"variance-boost-strength", &config_struct->variance_boost_strength},
         {"variance-octile", &config_struct->variance_octile},
         {"variance-boost-curve", &config_struct->variance_boost_curve},
+        {"qp-scale-compress-strength", &config_struct->qp_scale_compress_strength},
         {"fast-decode", &config_struct->fast_decode},
         {"luminance-qp-bias", &config_struct->luminance_qp_bias},
         {"enable-tf", &config_struct->enable_tf},
-- 
2.50.1

