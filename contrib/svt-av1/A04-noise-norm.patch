From 340b3af44db32257bdfd295ad2f43d1f656afcde Mon Sep 17 00:00:00 2001
From: Nomis101 <Nomis101@web.de>
Date: Sat, 16 Aug 2025 09:45:33 +0200
Subject: noise norm

Port of
https://github.com/psy-ex/svt-av1-psy/commit/dba0580ed409ffcd3dcf6be3e5325cd527f39aa0
https://github.com/psy-ex/svt-av1-psy/commit/2c69721e2035b2e04bc80df27c76a7158a77f130
https://github.com/psy-ex/svt-av1-psy/commit/9970318d094bff0378772dafac436d2bfbb02764
https://github.com/psy-ex/svt-av1-psy/commit/42093c307c0b6c8eafc3a172809e2e86d328a676
https://github.com/psy-ex/svt-av1-psy/commit/71e62a99b2484a48307da39950f91f0f91ad5c98

Signed-off-by: Nomis101 <Nomis101@web.de>
---
 Docs/Parameters.md                |   2 +
 Source/API/EbSvtAv1Enc.h          |  10 ++-
 Source/App/app_config.c           |   8 ++
 Source/Lib/Codec/full_loop.c      | 127 ++++++++++++++++++++++++++++++
 Source/Lib/Codec/pcs.h            |   1 +
 Source/Lib/Globals/enc_handle.c   |   4 +-
 Source/Lib/Globals/enc_settings.c |  13 ++-
 7 files changed, 162 insertions(+), 3 deletions(-)

diff --git a/Docs/Parameters.md b/Docs/Parameters.md
index f80a43f4..06447f6e 100644
--- a/Docs/Parameters.md
+++ b/Docs/Parameters.md
@@ -128,6 +128,8 @@ For more information on valid values for specific keys, refer to the [EbEncSetti
 | **TemporalFilteringStrength**    | --tf-strength                    | [0-4]      | 3           | Manually adjust temporal filtering strength. Higher values = stronger temporal filtering                                                             |
 | **LuminanceQpBias**              | --luminance-qp-bias              | [0-100]    | 0           | Adjusts a frame's QP based on its average luma value                                                                                                 |
 | **Sharpness**                    | --sharpness                      | [-7-7]     | 0           | Bias towards decreased/increased sharpness                                                                                                           |
+| **NoiseNormStrength**            | --noise-norm-strength           | [0-4]      | 0           | Selectively boost AC coefficients to improve fine detail retention in certain circumstances                  
+|
 
 
 ### **UseFixedQIndexOffsets** and more information
diff --git a/Source/API/EbSvtAv1Enc.h b/Source/API/EbSvtAv1Enc.h
index 6268629d..8d76acf8 100644
--- a/Source/API/EbSvtAv1Enc.h
+++ b/Source/API/EbSvtAv1Enc.h
@@ -966,6 +966,14 @@ typedef struct EbSvtAv1EncConfiguration {
     */
     uint8_t qp_scale_compress_strength;
 
+    /* @brief Noise normalization strength; modifies the encoder's willingness
+     * to boost AC coefficients in low-noise blocks.
+     * Min value is 0.
+     * Max value is 4.
+     * Default is 3.
+     */
+    uint8_t noise_norm_strength;
+
 #if FTR_SFRAME_POSI
     /* @brief Indicates where to insert an S-Frame, only available when sframe_mode is SFRAME_FLEXIBLE_ARF */
     SvtAv1SFramePositions sframe_posi;
@@ -973,7 +981,7 @@ typedef struct EbSvtAv1EncConfiguration {
 
     // clang-format off
     /*Add 128 Byte Padding to Struct to avoid changing the size of the public configuration struct*/
-    uint8_t padding[128 - (sizeof(uint8_t) * 3)
+    uint8_t padding[128 - (sizeof(uint8_t) * 4)
         - sizeof(bool)
 #if FTR_SFRAME_POSI
         - sizeof(SvtAv1SFramePositions)
diff --git a/Source/App/app_config.c b/Source/App/app_config.c
index 55ea896b..36f7e3c1 100644
--- a/Source/App/app_config.c
+++ b/Source/App/app_config.c
@@ -190,6 +190,8 @@
 #define MIN_CHROMA_QM_LEVEL_TOKEN "--chroma-qm-min"
 #define MAX_CHROMA_QM_LEVEL_TOKEN "--chroma-qm-max"
 
+#define NOISE_NORM_STRENGTH_TOKEN "--noise-norm-strength"
+
 #define STARTUP_MG_SIZE_TOKEN "--startup-mg-size"
 #define STARTUP_QP_OFFSET_TOKEN "--startup-qp-offset"
 #define ROI_MAP_FILE_TOKEN "--roi-map-file"
@@ -801,6 +803,8 @@ ConfigDescription config_entry_rc[] = {
     {LUMINANCE_QP_BIAS_TOKEN, "Adjusts a frame's QP based on its average luma value, default is 0 [0-100]"},
     // Sharpness
     {SHARPNESS_TOKEN, "Bias towards decreased/increased sharpness, default is 0 [-7 to 7]"},
+    //Noise normalisation strength
+    {NOISE_NORM_STRENGTH_TOKEN, "Noise normalization strength, default is 0 [0-4]"},
     // Termination
     {NULL, NULL}};
 
@@ -961,6 +965,10 @@ ConfigDescription config_entry_variance_boost[] = {
     {VARIANCE_BOOST_CURVE_TOKEN, "Curve for variance boost, default is 0 [0-3]"},
     // QP scale compress
     {QP_SCALE_COMPRESS_STRENGTH_TOKEN, "QP scale compress strength, default is 1 [0-3]"},
+
+    // Noise normalization strength
+    {NOISE_NORM_STRENGTH_TOKEN, "NoiseNormStrength", set_cfg_generic_token},
+
     // Termination
     {NULL, NULL}};
 
diff --git a/Source/Lib/Codec/full_loop.c b/Source/Lib/Codec/full_loop.c
index 71af54b1..e764372f 100644
--- a/Source/Lib/Codec/full_loop.c
+++ b/Source/Lib/Codec/full_loop.c
@@ -1464,6 +1464,133 @@ uint8_t svt_av1_compute_cul_level_c(const int16_t *const scan, const int32_t *co
     return (uint8_t)cul_level;
 }
 
+void svt_av1_perform_noise_normalization(MacroblockPlane *p,
+    QuantParam *qparam,
+    TranLow *coeff_ptr,
+    TranLow *qcoeff_ptr,
+    TranLow *dqcoeff_ptr,
+    TxSize tx_size,
+    TxType tx_type,
+    uint16_t *eob,
+    PictureControlSet *pcs)
+{
+    const int shift = av1_get_tx_scale_tab[tx_size];
+    const int width = get_txb_wide_tab[tx_size];
+    const int height = get_txb_high_tab[tx_size];
+    const ScanOrder *const scan_order = &av1_scan_orders[tx_size][tx_type];
+    const int16_t *scan = scan_order->scan;
+
+    // If block is too small, terminate early
+    if (width == 4 && height == 4) {
+        return;
+    }
+
+    uint8_t noisenorm_strength = pcs->scs->static_config.noise_norm_strength;
+
+    // If noisenorm_strength is 0, terminate early
+    if (noisenorm_strength < 1) {
+        return;
+    }
+
+    int best_si = -1;
+    int best_smallest_energy_gap = INT_MAX;
+    TranLow best_qc_low;
+    TranLow best_dqc_low;
+    int thresh;
+
+    // Determine threshold based on user-configurable noisenorm_strength
+    switch (noisenorm_strength) {
+        case 1:
+            thresh = 9;
+            break;
+        case 2:
+            thresh = 8;
+            break;
+        case 3:
+            thresh = 6;
+            break;
+        default:
+            thresh = 4;
+            break;
+    }
+
+    if (*eob > 1) {
+        // Textured block, boost the most suitable AC coefficient within the EOB range
+        for (int si = 1; si < *eob; si++) {
+            const int     ci     = scan[si];
+            const TranLow tqc    = coeff_ptr[ci];
+            const TranLow qc     = qcoeff_ptr[ci];
+            const TranLow dqc    = dqcoeff_ptr[ci];
+            const int     sign   = (tqc < 0) ? 1 : 0;
+
+            // Found candidate coefficient to boost (that's not being rounded up)
+            if (dqc != 0 && (abs(tqc) - abs(dqc)) > 0) {
+                const int dqv = get_dqv(p->dequant_qtx, ci, qparam->iqmatrix);
+                TranLow qc_low;
+                TranLow dqc_low;
+
+                TranLow abs_qc = (abs(qc) + 1) + 1; // add 1 as get_qc_dqc_low() expects it
+                get_qc_dqc_low(abs_qc, sign, dqv, shift, &qc_low, &dqc_low);
+
+                // Find energy gap and ratio
+                int energy_gap = abs(dqc_low - tqc);
+                int dq_step_size = abs(dqc_low - dqc);
+                int ratio = ((dq_step_size - energy_gap) << 4) / dq_step_size;
+
+                // Found coefficient with smaller energy gap, store it and continue
+                // "Energy gain/quant step size" ratio should be at least 6/16 to avoid boosting picked coeffs too much
+                // But we'll let users decide the threshold with the parameter
+                if (ratio >= thresh) {
+                    best_si = si;
+                    best_qc_low = qc_low;
+                    best_dqc_low = dqc_low;
+                }
+            }
+        }
+    } else if (*eob == 1) {
+        // Flat block, try to revive the most suitable AC coefficient not too far from DC
+        for (int si = 1; si < (width * height / 16); si++) {
+            const int     ci     = scan[si];
+            const TranLow tqc    = coeff_ptr[ci];
+            const TranLow dqc    = dqcoeff_ptr[ci];
+            const int     sign   = (tqc < 0) ? 1 : 0;
+
+            if (dqc == 0 && tqc != 0) {
+                // Found candidate coefficient (got quantized to 0)
+                const int dqv = get_dqv(p->dequant_qtx, ci, qparam->iqmatrix);
+                TranLow qc_low;
+                TranLow dqc_low;
+
+                TranLow abs_qc = 1 + 1; // add 1 as get_qc_dqc_low() expects it
+                get_qc_dqc_low(abs_qc, sign, dqv, shift, &qc_low, &dqc_low);
+
+                // Find energy gap and ratio
+                int energy_gap = abs(dqc_low - tqc);
+                int dq_step_size = abs(dqc_low - dqc);
+                int ratio = ((dq_step_size - energy_gap) << 4) / dq_step_size;
+
+                // Found coefficient with smaller energy gap, store it and continue
+                // "Energy gain/quant step size" ratio should be at least 6/16 to avoid boosting picked coeffs too much
+                // But we'll let users decide the threshold with the parameter
+                if (ratio >= thresh && energy_gap < best_smallest_energy_gap) {
+                    best_smallest_energy_gap = energy_gap;
+                    best_si = si;
+                    best_qc_low = qc_low;
+                    best_dqc_low = dqc_low;
+                }
+            }
+        }
+    }
+
+    if (best_si > 0) {
+        int best_ci = scan[best_si];
+        qcoeff_ptr[best_ci] = best_qc_low;
+        dqcoeff_ptr[best_ci] = best_dqc_low;
+        *eob = (best_si >= *eob) ? (best_si + 1) : *eob;
+    }
+
+}
+
 uint8_t svt_aom_quantize_inv_quantize(PictureControlSet *pcs, ModeDecisionContext *ctx, int32_t *coeff,
                                       int32_t *quant_coeff, int32_t *recon_coeff, uint32_t qindex,
                                       int32_t segmentation_qp_offset, TxSize txsize, uint16_t *eob,
diff --git a/Source/Lib/Codec/pcs.h b/Source/Lib/Codec/pcs.h
index 62394e05..fe755283 100644
--- a/Source/Lib/Codec/pcs.h
+++ b/Source/Lib/Codec/pcs.h
@@ -1191,6 +1191,7 @@ typedef struct PictureControlSetInitData {
     uint8_t tf_strength;
     bool    allintra;
     uint8_t qp_scale_compress_strength;
+    uint8_t noise_norm_strength;
 } PictureControlSetInitData;
 
 /**************************************
diff --git a/Source/Lib/Globals/enc_handle.c b/Source/Lib/Globals/enc_handle.c
index 4ee19042..f1b6c89f 100644
--- a/Source/Lib/Globals/enc_handle.c
+++ b/Source/Lib/Globals/enc_handle.c
@@ -1526,6 +1526,7 @@ EB_API EbErrorType svt_av1_enc_init(EbComponentType *svt_enc_component)
         input_data.variance_octile = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.variance_octile;
         input_data.tf_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.tf_strength;
         input_data.qp_scale_compress_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.qp_scale_compress_strength;
+        input_data.noise_norm_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.noise_norm_strength;
         input_data.static_config = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config;
         input_data.allintra = enc_handle_ptr->scs_instance_array[instance_index]->scs->allintra;
         EB_NEW(
@@ -4231,7 +4232,8 @@ static void copy_api_from_app(
     scs->max_input_luma_height = config_struct->source_height;
     // SB Definitions
     scs->static_config.pred_structure = ((EbSvtAv1EncConfiguration*)config_struct)->pred_structure;
-
+    // Noise normalization strength
+    scs->static_config.noise_norm_strength = config_struct->noise_norm_strength;
     scs->static_config.avif = ((EbSvtAv1EncConfiguration*)config_struct)->avif;
     scs->static_config.rtc = ((EbSvtAv1EncConfiguration*)config_struct)->rtc;
     if (scs->static_config.rtc && scs->static_config.pred_structure != LOW_DELAY) {
diff --git a/Source/Lib/Globals/enc_settings.c b/Source/Lib/Globals/enc_settings.c
index 2c2e8802..abf6192d 100644
--- a/Source/Lib/Globals/enc_settings.c
+++ b/Source/Lib/Globals/enc_settings.c
@@ -900,6 +900,11 @@ EbErrorType svt_av1_verify_settings(SequenceControlSet *scs) {
         return_error = EB_ErrorBadParameter;
     }
 
+    if (config->noise_norm_strength > 4) {
+        SVT_ERROR("Instance %u: Noise normalization strength must be between 0 and 4\n", channel_number + 1);
+        return_error = EB_ErrorBadParameter;
+    }
+
     return return_error;
 }
 
@@ -1053,6 +1058,7 @@ EbErrorType svt_av1_set_default_params(EbSvtAv1EncConfiguration *config_ptr) {
     config_ptr->lossless                          = false;
     config_ptr->avif                              = false;
     config_ptr->qp_scale_compress_strength        = 0;
+    config_ptr->noise_norm_strength               = 1;
 #if FTR_SFRAME_POSI
     config_ptr->sframe_posi.sframe_num   = 0;
     config_ptr->sframe_posi.sframe_posis = NULL;
@@ -1188,6 +1194,11 @@ void svt_av1_print_lib_params(SequenceControlSet *scs) {
         }
 
         SVT_INFO("SVT [config]: QP scale compress strength \t\t\t\t\t: %d\n", config->qp_scale_compress_strength);
+
+        if (config->noise_norm_strength >= 0) {
+            SVT_INFO("SVT [config]: Noise Normalization Strength \t: %d\n",
+                config->noise_norm_strength);
+        }
     }
 #if DEBUG_BUFFERS
     SVT_INFO("SVT [config]: INPUT / OUTPUT \t\t\t\t\t\t\t: %d / %d\n",
@@ -2053,7 +2064,7 @@ EB_API EbErrorType svt_av1_enc_parse_parameter(EbSvtAv1EncConfiguration *config_
         {"fast-decode", &config_struct->fast_decode},
         {"luminance-qp-bias", &config_struct->luminance_qp_bias},
         {"enable-tf", &config_struct->enable_tf},
-        {"tf-strength", &config_struct->tf_strength},
+        {"noise-norm-strength", &config_struct->noise_norm_strength},
     };
     const size_t uint8_opts_size = sizeof(uint8_opts) / sizeof(uint8_opts[0]);
 
-- 
2.50.1

