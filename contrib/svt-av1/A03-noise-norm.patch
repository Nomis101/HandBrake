From ca8341eaf714208b7df910523281321d29cf7bd8 Mon Sep 17 00:00:00 2001
From: Nomis101 <Nomis101@web.de>
Date: Fri, 3 Oct 2025 23:24:50 +0200
Subject: noise norm

Port of
https://github.com/psy-ex/svt-av1-psy/commit/dba0580ed409ffcd3dcf6be3e5325cd527f39aa0
https://github.com/psy-ex/svt-av1-psy/commit/2c69721e2035b2e04bc80df27c76a7158a77f130
https://github.com/psy-ex/svt-av1-psy/commit/9970318d094bff0378772dafac436d2bfbb02764
https://github.com/psy-ex/svt-av1-psy/commit/42093c307c0b6c8eafc3a172809e2e86d328a676
https://github.com/psy-ex/svt-av1-psy/commit/71e62a99b2484a48307da39950f91f0f91ad5c98

Signed-off-by: Nomis101 <Nomis101@web.de>
---
 Docs/Parameters.md                |   3 +-
 Source/API/EbSvtAv1Enc.h          |  12 ++-
 Source/App/app_config.c           |   8 ++
 Source/Lib/Codec/full_loop.c      | 120 ++++++++++++++++++++++++++++++
 Source/Lib/Codec/pcs.h            |   1 +
 Source/Lib/Globals/enc_handle.c   |   4 +-
 Source/Lib/Globals/enc_settings.c |  12 +++
 7 files changed, 156 insertions(+), 4 deletions(-)

diff --git a/Docs/Parameters.md b/Docs/Parameters.md
index 0a128bc6..61dc2d5f 100644
--- a/Docs/Parameters.md
+++ b/Docs/Parameters.md
@@ -131,7 +131,8 @@ For more information on valid values for specific keys, refer to the [EbEncSetti
 | **TemporalFilteringStrength**    | --tf-strength                    | [0-4]      | 3           | Manually adjust temporal filtering strength. Higher values = stronger temporal filtering                                                             |
 | **LuminanceQpBias**              | --luminance-qp-bias              | [0-100]    | 0           | Adjusts a frame's QP based on its average luma value                                                                                                 |
 | **Sharpness**                    | --sharpness                      | [-7-7]     | 0           | Bias towards decreased/increased sharpness                                                                                                           |
-
++| **NoiseNormStrength**            | --noise-norm-strength           | [0-4]      | 0           | Selectively boost AC coefficients to improve fine detail retention in certain circumstances                  
++|
 
 ### **UseFixedQIndexOffsets** and more information
 
diff --git a/Source/API/EbSvtAv1Enc.h b/Source/API/EbSvtAv1Enc.h
index 5b433e16..2484d212 100644
--- a/Source/API/EbSvtAv1Enc.h
+++ b/Source/API/EbSvtAv1Enc.h
@@ -1,4 +1,4 @@
-ï»¿/*
+/*
 * Copyright(c) 2019 Intel Corporation
 *
 * This source code is subject to the terms of the BSD 3-Clause Clear License and
@@ -968,6 +968,14 @@ typedef struct EbSvtAv1EncConfiguration {
     */
     uint8_t qp_scale_compress_strength;
 
+    /* @brief Noise normalization strength; modifies the encoder's willingness
+     * to boost AC coefficients in low-noise blocks.
+     * Min value is 0.
+     * Max value is 4.
+     * Default is 0 (off).
+     */
+    uint8_t noise_norm_strength;
+    
 #if FTR_SFRAME_POSI
     /* @brief Indicates where to insert an S-Frame, only available when sframe_mode is SFRAME_FLEXIBLE_ARF */
     SvtAv1SFramePositions sframe_posi;
@@ -1014,7 +1022,7 @@ typedef struct EbSvtAv1EncConfiguration {
      double ac_bias;
 
     /*Add 128 Byte Padding to Struct to avoid changing the size of the public configuration struct*/
-    uint8_t padding[128 - (sizeof(uint8_t) * 5)
+    uint8_t padding[128 - (sizeof(uint8_t) * 6)
         - (sizeof(bool) * 2)
         - sizeof(double)
 #if FTR_SFRAME_POSI
diff --git a/Source/App/app_config.c b/Source/App/app_config.c
index dcff0d18..fe97d11f 100644
--- a/Source/App/app_config.c
+++ b/Source/App/app_config.c
@@ -194,6 +194,8 @@
 #define MIN_CHROMA_QM_LEVEL_TOKEN "--chroma-qm-min"
 #define MAX_CHROMA_QM_LEVEL_TOKEN "--chroma-qm-max"
 
+#define NOISE_NORM_STRENGTH_TOKEN "--noise-norm-strength"
+
 #define STARTUP_MG_SIZE_TOKEN "--startup-mg-size"
 #define STARTUP_QP_OFFSET_TOKEN "--startup-qp-offset"
 #define ROI_MAP_FILE_TOKEN "--roi-map-file"
@@ -808,6 +810,8 @@ ConfigDescription config_entry_rc[] = {
     {LUMINANCE_QP_BIAS_TOKEN, "Adjusts a frame's QP based on its average luma value, default is 0 [0-100]"},
     // Sharpness
     {SHARPNESS_TOKEN, "Bias towards decreased/increased sharpness, default is 0 [-7 to 7]"},
+    //Noise normalisation strength
+    {NOISE_NORM_STRENGTH_TOKEN, "Noise normalization strength, default is 0 [0-4]"},
     // Termination
     {NULL, NULL}};
 
@@ -979,6 +983,10 @@ ConfigDescription config_entry_variance_boost[] = {
     {MAX_TX_SIZE_TOKEN, "Limits the allowed transform sizes to the specified, default is 64 [32,64]"},
     //AC-Bias
     {AC_BIAS_TOKEN, "Strength of AC bias in rate distortion, default is 0.0 [0.0-8.0]"},
+    
+    // Noise normalization strength
+    {NOISE_NORM_STRENGTH_TOKEN, "NoiseNormStrength", set_cfg_generic_token},
+
     // Termination
     {NULL, NULL}};
 
diff --git a/Source/Lib/Codec/full_loop.c b/Source/Lib/Codec/full_loop.c
index de5c97a0..435ddb73 100644
--- a/Source/Lib/Codec/full_loop.c
+++ b/Source/Lib/Codec/full_loop.c
@@ -1409,6 +1409,114 @@ uint8_t svt_av1_compute_cul_level_c(const int16_t *const scan, const int32_t *co
     return (uint8_t)cul_level;
 }
 
+void svt_av1_perform_noise_normalization(MacroblockPlane *p, QuantParam *qparam, TranLow *coeff_ptr,
+                                         TranLow *qcoeff_ptr, TranLow *dqcoeff_ptr, TxSize tx_size, TxType tx_type,
+                                         uint16_t *eob, PictureControlSet *pcs) {
+    const int width  = get_txb_wide_tab[tx_size];
+    const int height = get_txb_high_tab[tx_size];
+    if (width <= 4 && height <= 4) // If block is too small, terminate early
+        return;
+
+    const uint8_t noisenorm_strength = pcs->scs->static_config.noise_norm_strength;
+    if (noisenorm_strength < 1) // If noisenorm_strength is 0, terminate early
+        return;
+
+    const int              shift      = av1_get_tx_scale_tab[tx_size];
+    const ScanOrder *const scan_order = &eb_av1_scan_orders[tx_size][tx_type_to_scan_index[tx_type]];
+    const int16_t         *scan       = scan_order->scan;
+
+    int     best_si                  = -1;
+    int     best_smallest_energy_gap = INT_MAX;
+    TranLow best_qc_low;
+    TranLow best_dqc_low;
+    int     thresh;
+
+    // Determine threshold based on user-configurable noisenorm_strength
+    switch (noisenorm_strength) {
+    case 1: thresh = 9; break;
+    case 2: thresh = 8; break;
+    case 3: thresh = 6; break;
+    case 4: thresh = 4; break;
+    default: assert(0); break;
+    }
+
+    if (*eob > 1) {
+        // Textured block, boost the most suitable AC coefficient within the EOB range
+        for (int si = 1; si < *eob; si++) {
+            const int     ci   = scan[si];
+            const TranLow tqc  = coeff_ptr[ci];
+            const TranLow qc   = qcoeff_ptr[ci];
+            const TranLow dqc  = dqcoeff_ptr[ci];
+            const int     sign = (tqc < 0) ? 1 : 0;
+
+            // Found candidate coefficient to boost (that's not being rounded up)
+            if (dqc != 0 && (abs(tqc) - abs(dqc)) > 0) {
+                const int dqv = get_dqv(p->dequant_qtx, ci, qparam->iqmatrix);
+                TranLow   qc_low;
+                TranLow   dqc_low;
+
+                TranLow abs_qc = (abs(qc) + 1) + 1; // add 1 as get_qc_dqc_low() expects it
+                get_qc_dqc_low(abs_qc, sign, dqv, shift, &qc_low, &dqc_low);
+
+                // Find energy gap and ratio
+                int energy_gap   = abs(dqc_low - tqc);
+                int dq_step_size = abs(dqc_low - dqc);
+                int ratio        = ((dq_step_size - energy_gap) << 4) / dq_step_size;
+
+                // Found coefficient with smaller energy gap, store it and continue
+                // "Energy gain/quant step size" ratio should be at least 6/16 to avoid boosting picked coeffs too much
+                // But we'll let users decide the threshold with the parameter
+                if (ratio >= thresh) {
+                    best_si      = si;
+                    best_qc_low  = qc_low;
+                    best_dqc_low = dqc_low;
+                }
+            }
+        }
+    } else if (*eob == 1) {
+        // Flat block, try to revive the most suitable AC coefficient not too far from DC
+        for (int si = 1; si < (width * height / 16); si++) {
+            const int     ci   = scan[si];
+            const TranLow tqc  = coeff_ptr[ci];
+            const TranLow dqc  = dqcoeff_ptr[ci];
+            const int     sign = (tqc < 0) ? 1 : 0;
+
+            if (dqc == 0 && tqc != 0) {
+                // Found candidate coefficient (got quantized to 0)
+                const int dqv = get_dqv(p->dequant_qtx, ci, qparam->iqmatrix);
+                TranLow   qc_low;
+                TranLow   dqc_low;
+
+                TranLow abs_qc = 1 + 1; // add 1 as get_qc_dqc_low() expects it
+                get_qc_dqc_low(abs_qc, sign, dqv, shift, &qc_low, &dqc_low);
+
+                // Find energy gap and ratio
+                int energy_gap   = abs(dqc_low - tqc);
+                int dq_step_size = abs(dqc_low - dqc);
+                int ratio        = ((dq_step_size - energy_gap) << 4) / dq_step_size;
+
+                // Found coefficient with smaller energy gap, store it and continue
+                // "Energy gain/quant step size" ratio should be at least 6/16 to avoid boosting picked coeffs too much
+                // But we'll let users decide the threshold with the parameter
+                if (ratio >= thresh && energy_gap < best_smallest_energy_gap) {
+                    best_smallest_energy_gap = energy_gap;
+                    best_si                  = si;
+                    best_qc_low              = qc_low;
+                    best_dqc_low             = dqc_low;
+                }
+            }
+        }
+    }
+
+    if (best_si > 0) {
+        int best_ci = scan[best_si];
+        qcoeff_ptr[best_ci] = best_qc_low;
+        dqcoeff_ptr[best_ci] = best_dqc_low;
+        *eob = (best_si >= *eob) ? (best_si + 1) : *eob;
+    }
+
+}
+
 uint8_t svt_aom_quantize_inv_quantize(PictureControlSet *pcs, ModeDecisionContext *ctx, int32_t *coeff,
                                       int32_t *quant_coeff, int32_t *recon_coeff, uint32_t qindex,
                                       int32_t segmentation_qp_offset, TxSize txsize, uint16_t *eob,
@@ -1642,6 +1750,18 @@ uint8_t svt_aom_quantize_inv_quantize(PictureControlSet *pcs, ModeDecisionContex
                            (component_type == COMPONENT_LUMA) ? 0 : 1);
     }
 
+    if (is_encode_pass && *eob != 0 && tx_type != IDTX && (component_type == COMPONENT_LUMA)) {
+        svt_av1_perform_noise_normalization(&candidate_plane,
+                                            &qparam,
+                                            (TranLow *)coeff,
+                                            quant_coeff,
+                                            (TranLow *)recon_coeff,
+                                            txsize,
+                                            tx_type,
+                                            eob,
+                                            pcs);
+    }
+
     if (!ctx->rate_est_ctrls.update_skip_ctx_dc_sign_ctx)
         return 0;
 
diff --git a/Source/Lib/Codec/pcs.h b/Source/Lib/Codec/pcs.h
index 625de838..8a0e5620 100644
--- a/Source/Lib/Codec/pcs.h
+++ b/Source/Lib/Codec/pcs.h
@@ -1186,6 +1186,7 @@ typedef struct PictureControlSetInitData {
     uint8_t tf_strength;
     bool    allintra;
     uint8_t qp_scale_compress_strength;
+    uint8_t noise_norm_strength;
     bool    adaptive_film_grain;
     uint8_t max_tx_size;
     double  ac_bias;
diff --git a/Source/Lib/Globals/enc_handle.c b/Source/Lib/Globals/enc_handle.c
index 7df8df26..fa107d37 100644
--- a/Source/Lib/Globals/enc_handle.c
+++ b/Source/Lib/Globals/enc_handle.c
@@ -1529,6 +1529,7 @@ EB_API EbErrorType svt_av1_enc_init(EbComponentType *svt_enc_component)
         input_data.variance_octile = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.variance_octile;
         input_data.tf_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.tf_strength;
         input_data.qp_scale_compress_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.qp_scale_compress_strength;
+        input_data.noise_norm_strength = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.noise_norm_strength;
         input_data.adaptive_film_grain = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.adaptive_film_grain;
         input_data.max_tx_size = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.max_tx_size;
         input_data.ac_bias = enc_handle_ptr->scs_instance_array[instance_index]->scs->static_config.ac_bias;
@@ -4236,7 +4237,8 @@ static void copy_api_from_app(SequenceControlSet *scs, EbSvtAv1EncConfiguration
     scs->max_input_luma_height = config_struct->source_height;
     // SB Definitions
     scs->static_config.pred_structure = config_struct->pred_structure;
-
+    // Noise normalization strength
+    scs->static_config.noise_norm_strength = config_struct->noise_norm_strength;
     scs->static_config.avif = config_struct->avif;
     scs->static_config.rtc = config_struct->rtc;
     if (scs->static_config.rtc && scs->static_config.pred_structure != LOW_DELAY) {
diff --git a/Source/Lib/Globals/enc_settings.c b/Source/Lib/Globals/enc_settings.c
index a8b8faea..af2a52a3 100644
--- a/Source/Lib/Globals/enc_settings.c
+++ b/Source/Lib/Globals/enc_settings.c
@@ -927,6 +927,11 @@ EbErrorType svt_av1_verify_settings(SequenceControlSet *scs) {
         return_error = EB_ErrorBadParameter;
     }
 
+    if (config->noise_norm_strength > 4) {
+        SVT_ERROR("Instance %u: Noise normalization strength must be between 0 and 4\n", channel_number + 1);
+        return_error = EB_ErrorBadParameter;
+    }
+
     return return_error;
 }
 
@@ -1080,6 +1085,7 @@ EbErrorType svt_av1_set_default_params(EbSvtAv1EncConfiguration *config_ptr) {
     config_ptr->lossless                          = false;
     config_ptr->avif                              = false;
     config_ptr->qp_scale_compress_strength        = 0;
+    config_ptr->noise_norm_strength               = 0;
 #if FTR_SFRAME_POSI
     config_ptr->sframe_posi.sframe_num   = 0;
     config_ptr->sframe_posi.sframe_posis = NULL;
@@ -1243,6 +1249,11 @@ void svt_av1_print_lib_params(SequenceControlSet *scs) {
 
         SVT_INFO("SVT [config]: QP scale compress strength \t\t\t\t\t: %d\n", config->qp_scale_compress_strength);
 
+        if (config->noise_norm_strength >= 0) {
+            SVT_INFO("SVT [config]: Noise Normalization Strength \t: %d\n",
+                config->noise_norm_strength);
+        }
+
         if (config->ac_bias > 0.0) {
             SVT_INFO("SVT [config]: AC Bias Strength \t\t\t\t\t\t: %.2f\n", config->ac_bias);
         }
@@ -2280,6 +2291,7 @@ EB_API EbErrorType svt_av1_enc_parse_parameter(EbSvtAv1EncConfiguration *config_
         {"enable-tf", &config_struct->enable_tf},
         {"tf-strength", &config_struct->tf_strength},
         {"max-tx-size", &config_struct->max_tx_size},
+        {"noise-norm-strength", &config_struct->noise_norm_strength},
     };
     const size_t uint8_opts_size = sizeof(uint8_opts) / sizeof(uint8_opts[0]);
 
-- 
2.51.0

